import 'dart:async';

import 'package:breaking_bapp/data_source.dart';
import 'package:breaking_bapp/presentation/scene/character/list/character_list_states.dart';
import 'package:rxdart/rxdart.dart';

class CharacterListBloc {
  CharacterListBloc() {
    // The return type of the `listen` func is a `StreamSubscription`. You need
    // to store your subscriptions for being able to access and cancel
    // them if the widget (and consequently the BLoC) gets disposed.

    // We call "listen" twice in this BLoC, so we have two subscriptions. In
    // order to manage them together, we add both to a `CompositeSubscription`.
    _subscriptions
      // The '..' syntax is a Dart feature called cascade notation.
      // Further reading: https://dart.dev/guides/language/language-tour#cascade-notation-
      ..add(
        _fetchCharacterSummaryList().listen(_onNewStateController.add),
      )
      ..add(
        _onTryAgainController.stream
            // The flatMap function "switches" every emission of the
            // _onTryAgainController to a new Stream generated by the
            // _fetchCharacterSummaryList function.
            .flatMap((_) => _fetchCharacterSummaryList())
            .listen(_onNewStateController.add),
      );
  }

  final _subscriptions = CompositeSubscription();

  final _onTryAgainController = StreamController<void>();

  // Our _onTryAgainController is private to the BLoC. Instead of exposing it
  // entirely to the widget, we expose only its `Sink` side, as the `Stream`
  // part is only useful internally.
  Sink<void> get onTryAgain => _onTryAgainController.sink;

  final _onNewStateController = StreamController<CharacterListResponseState>();

  // Similarly, the _onNewStateController is also private to the BLoC.
  // Instead of exposing it entirely to the widget, we expose only its `Stream`
  // side, as the `Sink` part is only useful to the BLoC.
  Stream<CharacterListResponseState> get onNewState =>
      _onNewStateController.stream;

  // We're creating a new Stream inside this function using a Dart feature
  // named generator functions. Further reading:
  // https://dart.dev/guides/language/language-tour#generators
  Stream<CharacterListResponseState> _fetchCharacterSummaryList() async* {
    yield Loading();

    try {
      yield Success(
        await DataSource.getCharacterList(),
      );
    } catch (e) {
      yield Error();
    }
  }

  // Will be called by the widget when it gets disposed.
  void dispose() {
    // We need to close every instance of a `StreamController`.
    _onTryAgainController.close();
    _onNewStateController.close();
    _subscriptions.dispose();
  }
}
